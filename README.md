# Лабороторная работа по дисциплине "Язык программирования C++"

# ЛАБОРАТОРНАЯ РАБОТА №1 ПРОЦЕДУРНОЕ ПРОГРАММИРОВАНИЕ

# Вариант: 7

# Группа: ИТ-5-2024

# ФИО: Шалашов Андрей юрьевич

# Описание лабораторной работы:

Задание 1.1: Дробная часть.
Дана сигнатура функции: double fraction (double x);
Необходимо реализовать функцию таким образом, чтобы она возвращала
только дробную часть числа х. Подсказка: вещественное число может быть
преобразовано к целому путем отбрасывания дробной части.
Пример:
x=5,25
результат: 0,25

Задание 1.3: Букву в число.
Дана сигнатура функции: int charToNum (char x);
Функция принимает символ х, который представляет собой один из “0 1 2 3 4 5
6 7 8 9”. Необходимо реализовать функцию таким образом, чтобы она
преобразовывала символ в соответствующее число. Подсказка: код символа ‘0’
— это число 48.
Пример:
x=’3’
результат: 3

Задание 1.5: Двузначное.
Дана сигнатура функции: bool is2Digits (int x);
Необходимо реализовать функцию таким образом, чтобы она принимала число
x и возвращала true, если оно двузначное.
Пример 1:
x=32
результат: true
Пример 2:
x=516
результат: false

Задание 1.7: Диапазон.
Дана сигнатура функции: bool isInRange (int a, int b, int num);
Функция принимает левую и правую границу (a и b) некоторого числового
диапазона. Необходимо реализовать функцию таким образом, чтобы она
возвращала true, если num входит в указанный диапазон (включая границы).
Обратите внимание, что отношение a и b заранее неизвестно (неясно кто из них
больше, а кто меньше)
Пример 1:
a=5 b=1 num=3
результат: true
Пример 2:
a=2 b=15 num=33
результат: false

Задание 1.9: Равенство.
Дана сигнатура функции: bool isEqual(int a, int b, int c);
Необходимо реализовать функцию таким образом, чтобы она возвращала true,
если все три полученных функцией числа равны
Пример 1:
a=3 b=3 с=3
результат: true
Пример 2:
a=2 b=15 с=2
результат: false

Задание 2.1: Модуль числа.
Дана сигнатура функции: int abs (int x);
Необходимо реализовать функцию таким образом, чтобы она возвращала
модуль числа х (если оно было положительным, то таким и остается, если он
было отрицательным – то необходимо вернуть его без знака минус).
Пример 1:
x=5
результат: 5
Пример 2:
x=-3
результат: 3

Задание 2.3: Тридцать пять.
Дана сигнатура функции: bool is35 (int x);
Необходимо реализовать функцию таким образом, чтобы она возвращала true,
если число x делится нацело на 3 или 5. При этом, если оно делится и на 3, и на
5, то вернуть надо false. Подсказка: оператор % позволяет получить остаток от
деления.
Пример 1:
x=5
результат: true
Пример 2:
x=8
результат: false
Пример 3:
x=15
результат: false

Задание 2.5: Тройной максимум.
Дана сигнатура функции: int max3 (int x, int y, int z);
Необходимо реализовать функцию таким образом, чтобы она возвращала
максимальное из трех полученных функцией чисел. Подсказка: идеальное
решение включает всего две инструкции if и не содержит вложенных if.
Пример 1:
x=5 y=7 z=7
результат: 7
Пример 2:
x=8 y=-1 z=4
результат: 8

Задание 2.7: Двойная сумма.
Дана сигнатура функции: int sum2 (int x, int y);
Необходимо реализовать функцию таким образом, чтобы она возвращала
сумму чисел x и y. Однако, если сумма попадает в диапазон от 10 до 19, то надо
вернуть число 20.
Пример 1:
x=5 y=7
результат: 20
Пример 2:
x=8 y=-1
результат: 7

Задание 2.9: День недели.
Дана сигнатура функции: String day (int x);
Функция принимает число x, обозначающее день недели. Необходимо
реализовать функцию таким образом, чтобы она возвращала строку, которая
будет обозначать текущий день недели, где 1 — это понедельник, а 7 –
воскресенье. Если число не от 1 до 7 то верните текст “это не день недели”.
Вместо if в данной задаче используйте switch.
Пример:
x=5
результат: “пятница”

Задание 3.1: Числа подряд.
Дана сигнатура функции: String listNums (int x);
Необходимо реализовать функцию таким образом, чтобы она возвращала
строку, в которой будут записаны все числа от 0 до x (включительно).
Пример:
x=5
результат: “0 1 2 3 4 5”

Задание 3.3: Четные числа.
Дана сигнатура функции: String chet (int x);
Необходимо реализовать функцию таким образом, чтобы она возвращала
строку, в которой будут записаны все четные числа от 0 до x (включительно).
Подсказа для обеспечения качества кода: инструкцию if использовать не
следует.
Пример:
x=9
результат: “0 2 4 6 8”

Задание 3.5: Длина числа.
Дана сигнатура функции: int numLen (long x);
Необходимо реализовать функцию таким образом, чтобы она возвращала
количество знаков в числе x.
Подсказка:
Int у=123/10; // у будет иметь значение 12
Пример:
x=12567
результат: 5

Задание 3.7: Квадрат.
Дана сигнатура функции: void square (int x);
Необходимо реализовать функцию таким образом, чтобы она выводила на
экран квадрат из символов ‘*’ размером х, у которого х символов в ряд и х
символов в высоту.
Пример 1:
x=2
результат:
**
**
Пример 2:
x=4
результат:
****
****
****
****

Задание 3.9: Правый треугольник.
Дана сигнатура функции: void rightTriangle (int x);
Необходимо реализовать функцию таким образом, чтобы она выводила на
экран треугольник из символов ‘*’ у которого х символов в высоту, а количество
символов в ряду совпадает с номером строки, при этом треугольник выровнен
по правому краю. Подсказка: перед символами ‘*’ следует выводить
необходимое количество пробелов.
Пример 1:
x=3
результат:
|  *
| **
|***
Пример 2:
x=4
результат:
|   *
|  **
| ***
|****

Задание 4.1: Поиск первого значения.
Дана сигнатура функции: int findFirst (int arr[], int x);
Необходимо реализовать функцию таким образом, чтобы она возвращала индекс
первого вхождения числа x в массив arr. Если число не входит в массив –
возвращается -1.
Пример:
arr=[1,2,3,4,2,2,5]
x=2
результат: 1

Задание 4.3: Поиск максимального.
Дана сигнатура функции: int maxAbs (int arr[]);
Необходимо реализовать функцию таким образом, чтобы она возвращала
наибольшее по модулю (то есть без учета знака) значение массива arr.
Пример:
arr=[1,-2,-7,4,2,2,5]
результат: -7


Задание 4.5: Добавление массива в массив.
Дана сигнатура функции: int * add (int arr[], int ins[], int pos);
Необходимо реализовать функцию таким образом, чтобы она возвращала новый
массив, который будет содержать все элементы массива arr, однако в позицию pos
будут вставлены значения массива ins.
Пример:
arr=[1,2,3,4,5]
ins=[7,8,9]
pos=3
результат: [1,2,3,7,8,9,4,5]

Задание 4.7: Возвратный реверс.
Дана сигнатура функции: int * reverseBack (int arr[]);
Необходимо реализовать функцию таким образом, чтобы она возвращала новый
массив, в котором значения массива arr записаны задом наперед.
Пример:
arr=[1,2,3,4,5]
результат: [5,4,3,2,1]

Задание 4.9: Все вхождения.
Дана сигнатура функции: int * findAll (int arr[], int x);
Необходимо реализовать функцию таким образом, чтобы она возвращала новый
массив, в котором записаны индексы всех вхождений числа x в массив arr.
Пример:
arr=[1,2,3,8,2,2,9]
x=2
результат: [1,4,5]


##### Алгоритм решения:
    ЗАДАНИЕ 1.1: Дробная часть
Алгоритм:
Преобразовать число x к целому типу (отбросить дробную часть)
Вычесть целую часть из исходного числа
Вернуть полученную разность как дробную часть
Математически: дробная_часть = x - floor(x)

    ЗАДАНИЕ 1.3: Букву в число
Алгоритм:
Проверить, что символ находится в диапазоне '0'...'9'
Использовать свойство кодировки ASCII: код символа '0' = 48
Вычесть код '0' из кода полученного символа
Получить соответствующее число
Пример: '5' → 53 - 48 = 5

ЗАДАНИЕ 1.5: Двузначное
Алгоритм:
Проверить положительные двузначные числа: 10 ≤ x ≤ 99
Проверить отрицательные двузначные числа: -99 ≤ x ≤ -10
Вернуть true, если выполняется одно из условий
Вариант: (|x| ≥ 10) И (|x| ≤ 99)

ЗАДАНИЕ 1.7: Диапазон
Алгоритм:
Определить, какая из границ является левой (меньшей)
Определить, какая из границ является правой (большей)
Проверить: левая_граница ≤ num ≤ правая_граница
Вернуть результат проверки

ЗАДАНИЕ 1.9: Равенство
Алгоритм:
Сравнить a и b
Сравнить b и c
Вернуть true, если оба сравнения дали true
Логически: (a == b) И (b == c)

ЗАДАНИЕ 2.1: Модуль числа
Алгоритм:
Если число отрицательное: x < 0
Вернуть -x (инвертировать знак)
Иначе вернуть само число x
Кратко: x < 0 ? -x : x

ЗАДАНИЕ 2.3: Тридцать пять
Алгоритм:
Проверить делимость на 3: x % 3 == 0
Проверить делимость на 5: x % 5 == 0
Должно выполняться:
Делится на 3 ИЛИ на 5
НЕ делится одновременно на 3 И на 5
Логически: (делится_на_3 XOR делится_на_5)

ЗАДАНИЕ 2.5: Тройной максимум
Алгоритм:
Предположить, что первый элемент x - максимальный
Сравнить с y: если y > максимум, обновить максимум
Сравнить с z: если z > максимум, обновить максимум
Вернуть найденный максимум
Без вложенных if, только последовательные сравнения

ЗАДАНИЕ 2.7: Двойная сумма
Алгоритм:
Вычислить сумму: s = x + y
Проверить диапазон: 10 ≤ s ≤ 19
Если в диапазоне - вернуть 20
Иначе вернуть вычисленную сумму s

ЗАДАНИЕ 2.9: День недели
Алгоритм:
Использовать оператор switch для выбора варианта
Для каждого значения от 1 до 7 вернуть соответствующую строку
Для всех остальных значений вернуть сообщение об ошибке

ЗАДАНИЕ 3.1: Числа подряд
Алгоритм:
Создать пустую строку
Цикл от 0 до x включительно
На каждой итерации добавлять текущее число к строке
Добавлять пробел между числами (кроме последнего)
Вернуть полученную строку

ЗАДАНИЕ 3.3: Четные числа
Алгоритм:
Создать пустую строку
Цикл от 0 до x с шагом 2 (только четные числа)
На каждой итерации добавлять текущее число к строке
Добавлять пробел между числами (кроме последнего)
Вернуть полученную строку
Без if: используем шаг 2 вместо проверки четности

ЗАДАНИЕ 3.5: Длина числа
Алгоритм:
Если число равно 0 - вернуть 1 (особый случай)
Взять абсолютное значение числа (игнорировать знак)
Пока число больше 0:
Делить число на 10
Увеличивать счетчик цифр на 1
Вернуть счетчик
Пример: 123 → 123/10=12 (1 цифра), 12/10=1 (2 цифры), 1/10=0 (3 цифры)

ЗАДАНИЕ 3.7: Квадрат
Алгоритм:
Внешний цикл: i = 0 до x-1 (строки)
Внутренний цикл: j = 0 до x-1 (столбцы)
На каждой итерации внутреннего цикла выводить '*'
После каждой строки выводить перевод строки

ЗАДАНИЕ 3.9: Правый треугольник
Алгоритм:
Для строки i от 1 до x:
Вывести (x - i) пробелов
Вывести i звездочек
Перейти на новую строку
Выравнивание: пробелы слева создают смещение вправо

ЗАДАНИЕ 4.1: Поиск первого значения
Алгоритм:
Пройти по массиву от начала до конца
На каждом шаге сравнивать текущий элемент с x
Если найдено совпадение - вернуть индекс
Если дошли до конца без совпадений - вернуть -1

ЗАДАНИЕ 4.3: Поиск максимального по модулю
Алгоритм:
Предположить, что первый элемент - максимальный
Пройти по остальным элементам массива
Для каждого элемента:
Сравнить его модуль с модулем текущего максимума
Если больше - обновить максимум
Вернуть элемент с наибольшим модулем

ЗАДАНИЕ 4.5: Добавление массива в массив
Алгоритм:
Создать новый массив размером размер_arr + размер_ins
Скопировать первые pos элементов из arr
Скопировать все элементы из ins
Скопировать оставшиеся элементы из arr
Вернуть новый массив
Распределение индексов:
[0..pos-1] → arr[0..pos-1]
[pos..pos+insSize-1] → ins[0..insSize-1]
[pos+insSize..end] → arr[pos..end]

ЗАДАНИЕ 4.7: Возвратный реверс
Алгоритм:
Создать новый массив такого же размера
Пройти по исходному массиву
Заполнять новый массив, начиная с конца:
новый[i] = исходный[размер-1-i]
Вернуть новый массив

ЗАДАНИЕ 4.9: Все вхождения
Алгоритм:
Первый проход: посчитать, сколько раз x встречается в массиве
Создать новый массив размером = количество вхождений
Второй проход: сохранять индексы вхождений в новый массив
Вернуть массив индексов
Двухпроходный алгоритм: сначала считаем, потом собираем
